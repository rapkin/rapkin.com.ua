---
layout: layouts/post
---

_Переклад статті [A Recipe for Training Neural Networks](https://karpathy.github.io/2019/04/25/recipe/) від імені автора (Andrej Karpathy). З деякими додатковими посиланнями._

![Кожен раз коли хтось використовує нейронки аби вирішити якусь проблему](/assets/img/stonks-neural-networks.jpg)

Кілька тижнів тому я [опублікував](https://twitter.com/karpathy/status/1013244313327681536?lang=en) твіт на тему «найчастіші помилки з нейронками», перелічивши декілька загальних помилок які належать до навчання нейронних мереж. Твіт отримав дещо більше взаємодій ніж я очікував (включаючи цілий [вебінар](https://www.bigmarker.com/missinglink-ai/PyTorch-Code-to-Unpack-Andrej-Karpathy-s-6-Most-Common-NN-Mistakes) :)). Справді, багато людей помітили великий розрив між тим «ось як працює згортковий шар» та «наша згорткова мережа досягає результатів витвору мистецтва».

Тож я подумав, що буде весело змести пил зі свого блогу аби розкрити свій твіт в об'ємнішому форматі, якого і заслуговує ця тема. Однак замість того щоб поглиблюватись в перелік ще більшої кількості частих помилок або їх конкретизацію, я хотів би копнути глибше та поговорити про те як оминути ці помилки цілком (або ж виправити їх дуже швидко). Фокус в тому, щоб слідувати певному процесу, який, наскільки я можу сказати, не часто документується. Давайте почнемо з двох важливих спостережень, які спонукали до цього.


### 1) Нейронні мережі це дірява абстракція

Це ніби просто почати навчати нейронні мережі. Кілька бібліотек та фреймворків пишаються показом магічних 30-рядкових шматків коду які вирішують проблеми з вашими даними, даючи (хибні) враження, що це все працює з коробки. Звично бачити подібні речі:

```python
>>> your_data = # підставте свій датасет тут
>>> model = SuperCrossValidator(SuperDuper.fit, your_data, ResNet50, SGDOptimizer)
# підкоріть світ тут
```

Ці бібліотеки та приклади активують частину нашого мозку яка звична зі стандартними програмами - місце де чисті API та абстракції часто досяжні. Для прикладу бібліотека [requests](https://2.python-requests.org/en/master/):

```python
>>> r = requests.get('https://api.github.com/user', auth=('user', 'pass'))
>>> r.status_code
200
```

Круто! Сміливий розробник переклав на себе тягар розуміння рядків запитів, URL-адрес, GET/POST запитів, HTTP з'єднань, тощо, і багато в чому приховав складність за кількома рядками коду. Це те з чим ми знайомі та очікуємо. На жаль, нейронні мережі не схожі на це. Вони не "готова" технологія, коли ви трохи відхиляєтесь від навчання класифікатора [ImageNet](https://en.wikipedia.org/wiki/ImageNet). Я намагався вказати на це у своїй публікації ["Так ви маєте розуміти метод зворотного поширення помилки" (“Yes you should understand backprop”)](https://medium.com/@karpathy/yes-you-should-understand-backprop-e2f06eab496b), вибравши метод зворотного поширення помилки та назвавши його "дірявою абстракцією", але ситуація, на жаль, набагато важча. ["Зворотне поширення помилки"](https://uk.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%B7%D0%B2%D0%BE%D1%80%D0%BE%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D1%8F_%D0%BF%D0%BE%D0%BC%D0%B8%D0%BB%D0%BA%D0%B8) + ["Стохастичний градієнтний спуск"](https://uk.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D1%81%D1%82%D0%BE%D1%85%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B3%D1%80%D0%B0%D0%B4%D1%96%D1%94%D0%BD%D1%82%D0%B0) не робить вашу нейронну мережу магічно працюючою. Пакетна нормалізація не змушує її магічно [сходитись](https://en.wikipedia.org/wiki/Convergence_(logic)) швидше. [Рекурентні нейронні мережі](https://uk.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%B0_%D0%BD%D0%B5%D0%B9%D1%80%D0%BE%D0%BD%D0%BD%D0%B0_%D0%BC%D0%B5%D1%80%D0%B5%D0%B6%D0%B0) не дозволяють магічно "вставити" текст. І лише тому, що ви можете сформулювати вашу проблему в формі ["навчання з підкріпленням"](https://uk.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B2%D1%87%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7_%D0%BF%D1%96%D0%B4%D0%BA%D1%80%D1%96%D0%BF%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F%D0%BC) не означає, що ви повинні це робити. Якщо ви наполягаєте на використанні технології, не знаючи як вона працює, ви, ймовірно, зазнаєте невдачі. Що підводить мене до...


### 2) Навчання нейронних мереж ламається мовчки

Коли ви неправильно написали або налаштували код ви часто отримуєте певне виключення. Ви передали ціле число там де очікується рядок. Функція очікує лише 3 аргументи. Цей імпорт невдалий. Той ключ не існує. Кількість елементів у двох списках не рівна. В додачу, часто можливо створити юніт-тести для певного функціоналу.

Це лише початок, коли справа стосується тренування нейронних мереж. Все може бути синтаксично вірно, але вкупі не впорядковано належним чином, і про це справді важко сказати (компілятору або інтерпретатору). "Можлива поверхня помилок" велика, логічна (на відміну від синтаксичної) та дуже складна для юніт-тестування. Наприклад, ви забули перевернути шар позначень коли перевертали зображення під час [аугментації даних](https://en.wikipedia.org/wiki/Data_augmentation). Ваша мережа все ще (що шокує) може працювати досить добре, тому що ваша мережа може внутрішньо навчитися виявляти перевернуті зображення, а потім перевертати свої прогнози. Або, можливо, ваша авторегресивна модель випадково приймає те, що вона намагається передбачити, як інформацію на вході через непомітну помилку. Або ви намагалися обрізати свої градієнти, але замість цього обрізали втрату, що спричинило ігнорування [викидів](https://uk.wikipedia.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D0%B4_(%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0)), під час навчання. Або ви ініціалізували ваші ваги з попереднього навчання, але не використали вихідне середнє. Або ви просто зіпсували налаштування [регуляризації](https://uk.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D1%96%D1%8F_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)), швидкості навчання, розміру моделі, і т.д. Тому ваша неправильно налаштована нейронна мережа викине виключення, лише якщо вам пощастить; Здебільшого вона тренується, але мовчки працює трохи гірше.

Як результат, (і це дуууже складно переоцінити) __"швидкий і лютий" підхід до навчання нейронних мереж не працює__ і призводить лише до страждань. Зараз страждання є цілком природною частиною того, щоб нейронна мережа працювала добре, але їх можна пом'якшити, якщо бути вдумливими, захищеними, параноїдальними та одержимими візуалізацією практично всього. Якість, яка на моєму досвіді найбільше корелює з успіхом у глибокому навчанні, - це терпіння та увага до деталей.


## Рецепт

На тлі вищезгаданих двох фактів, я розробив для себе конкретний процес, якого я дотримуюсь, застосовуючи нейронну мережу до нової проблеми, і який я спробую описати. Ви побачите, що ці два принципи сприймаються дуже серйозно. Зокрема, проходить побудова від простого до складного та на кожному кроці ми робимо певні гіпотези про те, що станеться, а потім або перевіряємо їх експериментом, або досліджуємо, поки не знайдемо якоїсь проблеми. Те, чого ми намагаємось всіма силами запобігти - це введення великої кількості "неперевіреної" складності одразу, що обов'язково приведе до помилок або неправильної конфігурації, пошуки яких триватимуть вічно. Якби процес написання коду нейронної мережі був би подібним до навчання нейронки (тут написання коду нейронки вжито як пряма аналогія до навчання нейронки, але вже в вашому лиці), то ви хотіли б використовувати дуже малу швидкість навчання і вгадувати, а потім оцінювати повний набір тестів після кожної ітерації.


### 1. Станьте єдиними з даними

Перший крок до навчання нейронних мереж - це взагалі не торкатися коду нейронної мережі, а натомість почати з ретельної перевірки ваших даних. Цей крок критичний. Я люблю витрачати багато часу (вимірюється в годинах), перевіряючи тисячі прикладів, розуміючи їх розподіл та шукаючи закономірності. На щастя, ваш мозок добре з цим справляється. Одного разу я виявив, що дані містять приклади які повторюються. Іншого разу я виявив пошкоджені зображення / розмітку. Я шукаю дисбаланс даних та зміщення. Зазвичай я також звертаю увагу на свій власний процес класифікації даних, який натякає на види архітектур які ми з часом вивчимо. Як приклад - чи достатньо локальних особливостей, чи нам потрібен глобальний контекст? Скільки існує варіацій та яку форму вони приймають? Яка варіація хибна і може бути попередньо оброблена? Чи має значення просторове положення чи ми хочемо його усереднити (з допомогою операції average pool)? Наскільки важливі деталі і як далеко ми можемо дозволити собі зменшити розмір зображень? Наскільки шумна розмітка?

Крім того, оскільки нейронна мережа є фактично стисненою / скомпільованою версією вашого набору даних, ви зможете переглянути свої (помилкові) прогнози у вашій мережі та зрозуміти, звідки вони можуть надходити. І якщо ваша мережа дає вам прогноз який не відповідає тому, що ви бачили в даних, то щось пішло не так.

Отримавши розуміння якісної характеристики, також хорошою ідеєю є написання якогось простого коду для здійснення пошуку / фільтрування / сортування за будь-якою можливою характеристикою (наприклад, за типом мітки, розміром анотацій, кількістю анотацій тощо) та візуалізувати їх розподіл і викиди по будь-якій осі. Викиди майже завжди викривають якісь баги в даних або в їх підготовці.


### 2. Налаштуйте наскрізний скелет навчання / оцінки + отримайте простий базис (базову модель)

Тепер, коли ми зрозуміли наші дані, чи можемо ми дістатись до нашої надзвичайної великомасштабної ASPP FPN ResNet та розпочати навчання чудових моделей? Точно ні. Це шлях до страждань. Наш наступний крок - створити повний скелет _навчання + оцінка_ та завоювати довіру до його правильності шляхом серії експериментів. На цьому етапі найкраще вибрати якусь просту модель, яку не можна було якось зіпсувати - наприклад лінійний класифікатор або дуже крихітну згорткову мережу. Ми хочемо навчати мережу, візуалізувати втрати, будь-які інші показники (наприклад, точність), моделювати прогнози та проводити низку експериментів по [відключенню частин мережі](https://en.wikipedia.org/wiki/Ablation_(artificial_intelligence)) (при цьому висувати гіпотези як це вплине на результати) на всьому шляху.

Поради та підказки на цьому етапі:

 * __зафіксуйте [випадкове початкове значення](https://uk.wikipedia.org/wiki/%D0%92%D0%B8%D0%BF%D0%B0%D0%B4%D0%BA%D0%BE%D0%B2%D0%B5_%D0%BF%D0%BE%D1%87%D0%B0%D1%82%D0%BA%D0%BE%D0%B2%D0%B5_%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D1%8F)__. Завжди використовуйте фіксоване випадкове початкове значення аби гарантувати аналогічний результат при повторному запуску. Це усуває фактор варіативності та підтримає вашу впевненість.

 * __спрощуйте__. Не забудьте відключити будь-яку непотрібну химерність. Як приклад, на цьому етапі вимкніть будь-яку аугментацію даних. Аугментація даних - це стратегія регуляризації, яку ми можемо включити пізніше, але наразі це просто ще одна можливість внести якусь тупу помилку.

 * __додайте значущі цифри до вашої оцінки__. Під час побудови графіку тестових втрат проведіть оцінку по всьому (великому) набору тестів. Не просто складайте тестові втрати за партіями, а потім покладайтесь на їх згладжування в Tensorboard. Ми переслідуємо правильність і серйозно налаштовані приділити час для збереження впевненості.

 * __перевіряйте втрати на початку__. Переконайтеся, що показник втрати починається з правильного значення. Наприклад, якщо ви правильно ініціалізуєте свій кінцевий шар, то у вас повинно вийти `-log(1/n_classes)` для функції softmax при ініціалізації. Ті самі значення за замовчуванням можна отримати для регресії L2, втрат Губера тощо.

 * __вірно ініціалізуйте__. Правильно ініціалізуйте ваги кінцевого шару. Наприклад, якщо ви регресуєте деякі значення, які мають середнє значення 50, тоді ініціалізуйте остаточне зміщення до 50. Якщо у вас незбалансований набір даних зі співвідношенням 1:10, встановіть зміщення на своїх [логітах](https://en.wikipedia.org/wiki/Logit) так, щоб ваша мережа давала передбачення 0.1 при ініціалізації. Правильне їх встановлення пришвидшить збіжність та усуне криві втрат у вигляді "хокейної ключки", де у перші кілька ітерацій ваша мережа в основному лише вивчає зміщення.

 * __людський базис__. Відстежуйте й інші показники, крім втрат, які можна інтерпретувати та перевірити людиною (наприклад, точність). По можливості оцінюйте власну (людську) точність і порівнюйте з нею. Крім того, двічі анотуйте тестові дані та для кожного прикладу розгляньте одну анотацію як передбачення, а другу як [основну правду](https://uk.wikipedia.org/wiki/Ground_truth).

 * __незалежний від вхідних значень базис__. Тренуйте незалежний від вхідних значень базис (наприклад, найпростішим є встановлення всіх вхідних значень на нуль). Це має працювати гірше, ніж тоді, коли ви фактично підключаєте свої дані, не обнуляючи їх. Дійсно так? Дійсно ваша модель взагалі вчиться витягувати будь-яку інформацію із вхідних даних?

 * __перенавчайте на одній партії__. Робіть [перенавчання](https://uk.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%B2%D1%87%D0%B0%D0%BD%D0%BD%D1%8F) на одній партії лише кількома прикладами (наприклад, лише двома). Для цього ми збільшуємо обсяг нашої моделі (наприклад, додаємо шари або фільтри) і перевіряємо, що ми можемо досягти найнижчих досяжних втрат (наприклад, нульових). Мені також подобається візуалізувати на одному і тому ж графіку як розмічену інформацію, так і прогноз, аби переконатися, що вони ідеально вирівнюються, як тільки ми досягнемо мінімальних втрат. Якщо цього не сталося, десь є помилка, і ми не можемо перейти до наступного етапу.

 * __перевіряйте зменшення втрат на тренувальній вибірці__. Гадаю, ваш набір даних буде не дуже об'ємним, оскільки ви працюєте з іграшковою моделлю. Спробуйте трохи збільшити його обсяг. Значення втрат на тренувальній вибірці знизилися як слід?

 * __візуалізуйте безпосередньо перед входом нейронки__. Однозначно правильне місце для візуалізації ваших даних знаходиться безпосередньо перед вашим `y_hat = model(x)` (або `sess.run` у Tensorflow). Тобто - ви маєте візуалізувати саме те, що потрапляє у вашу мережу, декодуючи цей необроблений тензор даних та міток у вигляді якоїсь візуалізації. Це єдине “джерело істини”. Я не можу порахувати, скільки разів це мене рятувало та виявляло проблеми з попередньою обробкою та аугментацією даних.

 * __візуалізуйте динаміку прогнозів__. Мені подобається візуалізувати прогнози моделей на фіксованій тестовій партії під час навчання. "Динаміка" руху цих прогнозів дасть вам неймовірно хорошу інтуїцію щодо того, як прогресує тренування. Здебільшого можна відчути, як мережа «бореться» за розміщення ваших даних, якщо вона якось вагається, показуючи нестабільність. Дуже низька або дуже висока швидкість навчання також легко помітні за величиною тремтіння.

 * __використовуйте метод зворотного розповсюдження помилки для відстежування залежностей__. Ваш код для глибокого навчання часто міститиме складні, векторизовані та трансляційні операції. Досить поширена помилка, з якою я стикався кілька разів, полягає в тому, що люди досягають цього неправильно (наприклад, вони використовують `view`, а не `transpose/permute`) і ненавмисно змішують інформацію у вимірі розміру пакета. Пригнічує той факт, що ваша мережа, як правило, все одно добре навчатиметься, тому що вона навчиться ігнорувати дані з інших прикладів. Одним зі способів налагодження цієї (та інших пов'язаних з цим проблем) є встановлення функції втрати як чогось тривіального, такого як сума всіх виходів прикладу _i_, запуск зворотного проходу аж до вхідного сигналу та забезпечення отримання ненульового градієнта лише на _i_-му вході. Ту саму стратегію можна використовувати аби переконатись, що ваша авторегресивна модель у момент часу _t_ залежить лише від _1..t-1_. Більш загально, градієнти дають вам інформацію про те, що і від чого залежить у вашій мережі, це може бути корисно для налагодження.

 * __узагальнюйте окремий випадок__. Це більше схоже на пораду узагальнювати код, але я часто бачив, як люди роблять помилки, коли відкушують більше, ніж можуть жувати, пишучи відносно загальну функціональність з нуля. Мені подобається писати дуже конкретну функцію для того, що я роблю зараз, змусити це працювати, а потім узагальнити її пізніше, переконавшись, що я отримаю той самий результат. Часто це стосується векторизації коду, де я майже завжди виписую повністю циклічну версію, а вже потім перетворюю її на векторизований код по одному циклу.


### 3. Перенавчайте

На цьому етапі ми повинні добре розуміти набір даних, і ми маємо повний конвеєр навчання + оцінки. Для будь-якої даної моделі ми можемо (відтворювано) обчислити метрику, якій ми довіряємо. Ми також озброєні результатами нашого незалежного від вхідних даних базису, результатами кількох простих базисів (нам краще перемогти саме їх), і ми маємо приблизне відчуття продуктивності людини (ми сподіваємось досягти цього рівня). Поточний етап направлений на ітерації в напрямку хорошої моделі.

Підхід, який я люблю застосовувати до пошуку хорошої моделі, складається з двох етапів: спочатку отримати модель, достатньо велику, щоб вона могла перенавчитись (тобто зосередити увагу на значенні втрат тренувальної вибірки), а потім регулювати її належним чином (погіршити деякі значення втрат навчальної вибірки, щоб покращити значення втрат під час перевірки). Причиною, чому мені подобаються ці два етапи, є те, що якщо ми не можемо досягти низького рівня помилок з будь-якою моделлю взагалі, це може знову вказувати на якісь проблеми, помилки або неправильну конфігурацію.

Кілька порад та підказок на цьому етапі:

 * __підбір моделі__. Щоб досягти хороших значень втрат навчальної вибірки, ви маєте вибрати відповідну архітектуру даних. Коли справа доходить до її вибору, моя перша порада: __Не будьте героєм__. Я бачив багато людей, які прагнуть зійти з розуму в креативності підбору лего-блоків з набору інструментів нейронних мереж у процесі створення різних екзотичних архітектур, які мають сенс лише для них. На перших етапах проекту всіма силами чиніть опір цій спокусі. Я завжди раджу людям просто знайти найбільш схожу наукову роботу і скопіювати її найпростішу архітектуру, яка забезпечує хороші показники. Наприклад якщо ви класифікуєте зображення, не будьте героєм, а просто скопіюйте ResNet-50 для першого запуску. Ви зможете робити щось більш специфічне пізніше і перемогти цей пункт.

 * __Adam (метод адаптивної оцінки моментів) безпечний__. На ранніх стадіях встановлення базису мені подобається використовувати Adam зі швидкістю навчання `3e-4`. З мого досвіду, Adam набагато лояльніший до гіперпараметрів, включаючи погану швидкість навчання. Для згорткових нейронок добре налаштований метод стохастичного градієнта (SGD) майже завжди трохи перевершує Adam, але область оптимальної швидкості навчання набагато вужча і залежить від задачі. (Примітка. Якщо ви використовуєте рекурентні нейронки та пов’язані з ними моделі обробки послідовностей, то частіше використовують Adam. Знову ж таки, на початковому етапі свого проекту не будьте героєм і дотримуйтесь усіх найпопулярніших статей.)

 * __ускладнюйте лише по одному__. Якщо у вас є кілька сигналів для підключення до вашого класифікатора, я б порадив вам приєднати їх один за одним і кожного разу переконуватись, що ви отримуєте підвищення продуктивності, яке ви очікували. Не кидайте відро помий на свою модель на самому початку. Є й інші способи нарощення складності - наприклад, ви можете спробувати підключити спочатку менші зображення, а пізніше збільшити їх тощо.

 * __не довіряйте коефіцієнту зменшення швидкості навчання за замовчуванням__. Якщо ви переробляєте код з якоїсь іншої задачі, завжди будьте дуже обережні зі зниженням швидкості навчання. Ви не тільки хотіли б використовувати різні графіки зниження швидкості навчання для різних проблем, але - що ще гірше - у типовій реалізації зниження базуватиметься на поточному номері епохи, який може широко варіюватися просто залежно від розміру вашого набору даних. Наприклад, ImageNet сповільниться у 10 разів на 30-й епосі. Якщо ви не тренуєтеся з ImageNet (мається на увазі розмір датасету), ви, майже напевно, цього не хочете. Якщо ви не будете обережні, ваш код може потайки зводити вашу швидкість навчання до нуля занадто рано, не дозволяючи вашій моделі сходитися. У своїй власній роботі я завжди повністю вимикаю рівень зниження швидкості навчання (я використовую постійну швидкість навчання) і налаштовую це в самому кінці.


### 4. Регуляризуйте

В ідеалі, ми зараз знаходимося в тому місці, де маємо велику модель, яка підходить як мінімум для навчального набору. Зараз настав час його регуляризувати та отримати певну точність перевірки, відмовившись від частини точності на навчальній вибірці. Деякі поради та підказки:

 * __отримайте більше даних__. По-перше, безумовно найкращим способом регуляризування моделі в будь-якому практичному середовищі є додавання більшої кількості реальних навчальних даних. Дуже поширеною помилкою є проведення багатьох інженерних циклів, намагаючись вичавити сік з невеликого набору даних, коли замість цього можна було збирати більше даних. Наскільки мені відомо, додавання додаткових даних є чи не єдиним гарантованим способом монотонно покращувати продуктивність добре налаштованої нейронної мережі майже необмежено довго. Інші - це ансамблі нейронок (якщо ви можете їх собі дозволити), але це обмежується ~ 5-ма моделями.

 * __аугментація даних__. Наступним найкращим способом після реальних даних є напівфальшиві дані - спробуйте більш агресивну аугментацію даних.

 * __креативна аугментація__. Якщо напівфальшиві дані не допомогли, фейкові дані також можуть щось зробити. Люди знаходять творчі способи розширення наборів даних; Наприклад, [рандомізація доменів](https://openai.com/blog/learning-dexterity/), використання [моделювання](https://vladlen.info/publications/playing-data-ground-truth-computer-games/), розумні [гібриди](https://arxiv.org/abs/1708.01642), такі як вставка (потенційно змодельована) даних у сцени або навіть [GAN](https://uk.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0_%D0%B7%D0%BC%D0%B0%D0%B3%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0_%D0%BC%D0%B5%D1%80%D0%B5%D0%B6%D0%B0).

 * __попередньо натреновуйте__. Рідко коли-небудь шкодить використовувати попередньо навчену мережу, якщо вам дозволяє ситуація, навіть якщо у вас достатньо даних.

 * __дотримуйтеся контрольованого навчання (навчання з учителем)__. Не переоцінюйте попереднє навчання без нагляду (без учителя). На відміну від того, що розповідається в тому дописі в блозі від 2008 року [не можу зрозуміти про який допис тут йде мова], наскільки мені відомо, немає версій які показують хороші результати на сучасних завданнях комп'ютерного зору (хоча [NLP](https://uk.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%BE%D0%B1%D0%BA%D0%B0_%D0%BF%D1%80%D0%B8%D1%80%D0%BE%D0%B4%D0%BD%D0%BE%D1%97_%D0%BC%D0%BE%D0%B2%D0%B8), здається, цілком добре справляється разом з [BERT](https://uk.wikipedia.org/wiki/BERT_(%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BC%D0%BE%D0%B2%D0%B8)) та компанією на сьогодні, цілком імовірно завдяки навмисному характеру тексту та вищому співвідношенню _сигнал / шум_).

 * __зменшуйте вхідну розмірність__. Видаліть приклади, які можуть містити помилковий сигнал. Будь-який доданий помилковий ввід - це лише чергова можливість перенавчити (коли ваша нейронка зазубрить приклад), якщо ваш набір даних невеликий. Подібним чином, якщо деталі низького рівня не мають великого значення, спробуйте передавати зображення меншого розміру.

 * __зменшуйте розмір моделі__. У багатьох випадках ви можете використовувати обмеження інформативності ділянки в мережі, щоб зменшити її розмір. Як приклад, раніше було модно використовувати шари з повним з'єднанням поверх основи з ImageNet, але відтоді вони були замінені простим середнім об’єднанням (average pooling), усуваючи тонну параметрів у процесі.

 * __зменшуйте розмір партії__. Через нормалізацію всередині норми партії менші розміри партії дещо відповідають сильнішій регуляризації регуляризації. Це пов’язано з тим, що емпіричне _середнє/стандартний розподіл_ для партії є більш приблизними версіями _повного середнього/стандартний розподіл_, тому зміна масштабу і зміщення "гойдають" вашу партію більше.

 * __відсіюйте__. Додайте відсіювання. Використовуйте dropout2d (просторове відсіювання) для згорткових мереж. Використовуйте це помірковано/обережно, оскільки, здається, відсіювання не добре працює при нормалізації партії.

 * __зменшення ваги__. Збільште коефіцієнт зменшення ваги (ефект забування).

 * __рання зупинка__. Зупиняйте тренування на основі виміряних валідаційних втрат, щоб зловити свою модель саме тоді, коли вона збирається перенавчитися (зазубрити приклади, а не вивчити загальні особливості).

 * __спробуйте більшу модель__. Я згадую це останнім і лише після ранньої зупинки, адже раніше я кілька разів виявляв, що більші моделі з часом, звичайно, перенавчаються набагато сильніше, але їхня “зупинена” ефективність часто може бути набагато кращою, ніж у моделей меншого розміру.

Нарешті, щоб отримати додаткову впевненість у тому, що ваша мережа є розумним класифікатором, я люблю візуалізувати ваги першого рівня мережі та гарантувати, що ви отримуєте гарні межі, які мають сенс. Якщо ваші фільтри першого шару схожі на шум, тоді щось може бути не так. Подібним чином активації всередині мережі іноді можуть показувати дивні артефакти та натякати на проблеми.


### 5. Тюнінгуйте

Тепер ви повинні бути "зв'язані" з вашим набором даних, вивчаючи широкий простір моделей для архітектур, які досягають низьких втрат під час перевірки. Кілька порад та підказок для цього кроку:

 * __випадковий пошук по сітці__. Для одночасного налаштування декількох гіперпараметрів може здатися спокусливим використовувати пошук по сітці, щоб забезпечити охоплення всіх налаштувань, але майте на увазі, що найкраще замість цього використовувати випадковий пошук. Інтуїтивно це пов’язано з тим, що нейронні мережі часто набагато чутливіші до одних параметрів, ніж до інших. Загалом, якщо параметр _a_ важливий, але зміна _b_ не має ефекту, ви підбираєте значення _a_ більш продумано, ніж у кількох фіксованих точках декілька разів.

 * __оптимізація гіперпараметрів__. Навколо є велика кількість вигадливих наборів інструментів для оптимізації байєсових гіперпараметрів, і кілька моїх друзів також повідомили про успіх з ними, але мій особистий досвід полягає в тому, що сучасний підхід до вивчення прекрасного та широкого простору моделей та гіперпараметрів полягає у використанні інтерна :). Жартую.


### 6. Витисніть всі соки

Знайшовши найкращі типи архітектур та гіперпараметри, ви все ще можете скористатися ще кількома хитрощами, щоб вичавити останні каплі соку з системи:

 * __ансамблі__. Ансамблі моделей - це майже гарантований спосіб отримати 2% точності на чому-небудь. Якщо ви не можете дозволити собі обчислення під час тестування, погляньте на перегонку свого ансамблю в мережу, використовуючи [темні знання](https://arxiv.org/abs/1503.02531).

 * __залиште її тренуватись__. Я часто бачив людей, які спокушаються припинити навчання моделей, коли втрата валідації, здається, вирівнюється. З мого досвіду, мережі продовжують тренуватися неінтуїтивно довго. Одного разу я випадково покинув тренування моделі під час зимових канікул, і коли повернувся в січні, я побачив SOTA (state of the art - “сучасний рівень”).

## Висновок

Як тільки ви потрапите сюди, у вас будуть усі складові успіху: Ви глибоко розумієте технологію, набір даних та проблему, ви створили всю інфраструктуру навчання / оцінки та досягли високої впевненості у її точності, Ви досліджували дедалі складніші моделі, отримуючи поліпшення продуктивності способами, які ви передбачали на кожному кроці. Тепер ви готові прочитати багато робіт, спробувати велику кількість експериментів і отримати свої результати SOTA. Удачі!
